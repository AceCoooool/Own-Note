> 下述内容来自：[interview c++](https://github.com/huihut/interview#cc)

## const

#### 作用

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针和指针常量；
3. 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

#### 例子

```cpp
// 类
class A {
private:
    const int a;                // 常对象成员，只能在初始化列表赋值

public:
    // 构造函数
    A() {};
    A(int x) : a(x) {};        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function() {
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数
    const A a;                  // 常对象，只能调用常成员函数、更新常成员变量
    const A *p = &a;            // 常指针
    const A &q = a;             // 常引用

    // 指针
    char greeting[] = "Hello";
    char *p1 = greeting;                // 指针变量，指向字符数组变量
    const char *p2 = greeting;          // 指针变量，指向字符数组常量
    char *const p3 = greeting;          // 常指针，指向字符数组变量
    const char *const p4 = greeting;    // 常指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char *Var);         // 参数指针所指内容为常量
void function3(char *const Var);         // 参数指针为常指针
void function4(const int &Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int *function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int *const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
```

## noexcept

> 无条件的noexcept就是为了不会发射异常的函数准备的。

主要的用处：对不会发射异常的函数应用noexcept声明可以让编译器生成更好的目标代码

一般遵从下述两个原则来决定用不用：

1. noexcept性质对于移动操作，swap，函数释放函数和析构函数最有价值
2. 大多数函数都是异常中立的，不具备noexcept性质

> [知乎-神奇先生](https://www.zhihu.com/question/30950837)给的建议是：
>
> - 默认不使用
> - move constructor/assignment operator 如果不会抛出异常，一定用noexcept
> - destructor一定用noexcept
> - 简单的leaf function，像是int，pointer这类的getter，setter用noexcept。因为不可能出错

## explicit

> 只用来修饰构造函数

用处：explicit 修饰的构造函数可用来防止隐式转换

#### 例子

```cpp
class Test1 {
public:
    Test1(int n) {           // 普通构造函数
        num = n;
    }
private:
    int num;
};

class Test2 {
public:
    explicit Test2(int n) {  // explicit（显式）构造函数
        num = n;
    }
private:
    int num;
};

int main() {
    Test1 t1 = 12;            // 隐式调用其构造函数，成功
    Test2 t2 = 12;            // 编译错误，不能隐式调用其构造函数
    Test2 t2(12);             // 显式调用成功
    return 0;
}
```

## static_cast

- 用于非多态类型的转换
- 不执行运行时类型检查（转换安全性不如 dynamic_cast）
- **通常用于转换数值数据类型（如 float → int）**
- 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）

> 向上转换是一种隐式转换。

## this

1. `this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 `this` 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。
6. 在以下场景中，经常需要显式引用`this`指针：
   - 为实现对象的链式引用；
   - 为避免对同一对象进行赋值操作；
   - 在实现一些数据结构时，如 `list`。



## 各类构造函数

#### ① 默认构造函数

```cpp
class A {
public:
//    A() = default;   // 第一种形式的默认构造函数---这里其实是没有初始化的
    A(int a = 10, int b = 20) {}  // 第二种形式的默认构造函数
    int a;
    int b;
};
```

很详细的一篇说明：[C++合成默认构造函数](https://www.cnblogs.com/QG-whz/p/4676481.html)

1. 什么是默认构造函数？**默认构造函数是可以不用实参进行调用的构造函数，它包括了以下两种情况：**

   - 没有带明显形参的构造函数
   - 提供了**默认实参**的构造函数

2. 怎么样的类才是编译器需要合成的默认构造函数？

   1. 合成默认构造函数总是不会初始化类的**内置类型及复合类型的数据成员**
   2. 分清楚默认构造函数被程序需要与被编译器需要，只有**被编译器需要**的默认构造函数，编译器才会合成它

3. 何时默认构造函数才会被编译器需要？

   1. 含有类对象数据成员，该类对象类型有默认构造函数
   2. 基类带有默认构造函数的派生类
   3. 带有虚函数的类
   4. 带有虚基类的类


#### ② 拷贝构造函数（也称复制构造函数） 

```cpp
class A {
public:
    A(int val) : x(val) {}
    A(const A &rhs) {  // 拷贝构造函数
        x = rhs.x;
    }
private:
    int x;
};

A a = A(10);  // 相当于调用了拷贝构造函数
```

关于何时调用了拷贝构造函数，可以参考：[蓝色的回答](https://www.zhihu.com/question/30726582/answer/49210382)

总结起来就是一句话：对于拷贝构造来说，归根结底，落脚点在构造函数上。所以调用拷贝构造的时候，一定是这个对象不存在的时候（注意`A a;`只是声明，这个对象并不存在）

> 拷贝构造函数并不会对被拷贝对象做什么，只是单纯的拷贝一份

#### ③ 移动构造函数

```cpp
class A {
public:
    A(A &&rhs) {  // 移动构造函数
        x = rhs.x;
        rhs.x = nullptr;        
    }
private:
    int* x;
};
```

可以简单的理解为"抢掉"了输入对象的空间（输入对象被"抛弃"了）

（这部分更深入的讨论可看：[关于move的讨论](https://stackoverflow.com/questions/3106110/what-are-move-semantics)）

## 赋值运算符&移动赋值运算符

```cpp
// 下述为伪代码
class A {
public:
    ...
    
    A &operator=(const A &a) noexcept {   // 赋值运算符
        A tmp(a);
        swap(this->data, tmp.data);
    }

    A &operator=(A &&) noexcept {        // 移动赋值运算符
        this->data = A.data;
        A.data = nullptr;
    }

private:
    ...
};
```
## 零碎记忆点

#### `<algorithm>`中

- `copy_back(BidirIt1 first, BidirIt1 last, BidirIt2 d_last)`：制来自 `[first, last)` 所定义范围的元素，到终止位置为`d_last` 的范围（以逆序复制元素（首先复制末元素），但保持其相对顺序）
- `OutputIt copy( InputIt first, InputIt last, OutputIt d_first )`：复制 `[first, last)` 所定义的范围中的元素到始于 `d_first` 的另一范围（返回指向目标范围中最后复制元素的下个元素的输出迭代器）



### Others

- 模板类里面的模板函数，此时如果"成员函数"写在外部的写法

  ```cpp
  template<class T, class Alloc>   // 类模板
  template<class InputIterator>    // 函数模板
  void list<T, Alloc>::insert(iterator position, InputIterator first, InputIterator last) {
      for (--last; first != last; --last)
          position = insert(position, *last);
      insert(position, *last);
  }
  ```

  ​